<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Distributed Systems | emodemo’s notes</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Distributed Systems" />
<meta name="author" content="emodemo" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="emodemo’s notes on development, fiction, science and other stuff." />
<meta property="og:description" content="emodemo’s notes on development, fiction, science and other stuff." />
<link rel="canonical" href="/dev/Distributed.html" />
<meta property="og:url" content="/dev/Distributed.html" />
<meta property="og:site_name" content="emodemo’s notes" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Distributed Systems" />
<script type="application/ld+json">
{"url":"/dev/Distributed.html","@type":"WebPage","author":{"@type":"Person","name":"emodemo"},"headline":"Distributed Systems","description":"emodemo’s notes on development, fiction, science and other stuff.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="emodemo's notes" /><script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script></head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">emodemo&#39;s notes</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/pages/dev.html">Development</a><a class="page-link" href="/pages/fiction.html">Fiction</a><a class="page-link" href="/pages/science.html">Science</a><a class="page-link" href="/pages/else.html">Other Stuff</a><a class="page-link" href="/pages/library.html">Library</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Distributed Systems</h1>
  </header>

  <div class="post-content">
    <!-- default one if nothing else is mentioned -->
<ul>
  <li>Rancher  + Rancher  OS for Docker and Kubernetes</li>
  <li>CoreOS designed with Docker in mind - well optimized Linux for Docker</li>
  <li>Hystrix, Suro, Riemann, Prometheus + , Kibana</li>
  <li>Raft Consensus Algorithm, see http://thesecretlivesofdata.com/raft</li>
  <li>jepsen.io distributed system testing. see also hazelcast github with it.</li>
  <li><a class="citation" href="#kleppmann2017designing">(Kleppmann, 2017; Rivers, 2017)</a></li>
</ul>

<h2 id="cap-fedosov-nd">CAP <a class="citation" href="#fedosovDistChetaSheet">(Fedosov, n.d.)</a></h2>

<ul>
  <li>Only 2 of these can be chosen (in practice either AP or CP)
    <ul>
      <li>consistency - all nodes will see same data</li>
      <li>availability - fastest availability, ignoring accuracy</li>
      <li>Partition tolerance - survive network failures</li>
    </ul>
  </li>
</ul>

<h2 id="measurements">Measurements</h2>

<ul>
  <li>throughput: requests per second, or total time to run a job</li>
  <li>latency: wait to process time (e.g. request is latent, awaiting service)</li>
  <li>response time: time to process + network delay + queueing delay + etc.</li>
  <li>read/write ration: think of where most work will be done</li>
  <li><a class="citation" href="#newman2015building">(Newman, 2015)</a> Underlying OS</li>
  <li><a class="citation" href="#newman2015building">(Newman, 2015)</a> CPU per service, per Application, per Node (if more than 1)</li>
</ul>

<h3 id="logging">Logging</h3>

<ul>
  <li><strong>[me]</strong> External and Centralized</li>
  <li><a class="citation" href="#newman2015building">(Newman, 2015)</a> Standardize: how, where and output format of logging.</li>
  <li><a class="citation" href="#newman2015building">(Newman, 2015)</a> Use correlation IDs to track the request in all services</li>
  <li><a class="citation" href="#newman2015building">(Newman, 2015)</a> Use a query tool, add alerts</li>
  <li><strong>[me]</strong> Timestamps for in/out</li>
  <li><strong>[me]</strong> Dynamically changeable logging level (e.g. with settings file)</li>
</ul>

<h3 id="app-level-me">App Level <strong>[me]</strong></h3>

<ul>
  <li>profiling</li>
  <li>method/call
    <ul>
      <li>execution time</li>
      <li>N of calls (frequency)</li>
      <li>who calls + execution paths</li>
    </ul>
  </li>
</ul>

<h2 id="design-advices">Design Advices</h2>

<ul>
  <li>Think of where most of work will be done (based on read/write ration)</li>
</ul>

<h2 id="time-order-and-causality">Time, Order and Causality</h2>

<ul>
  <li><a class="citation" href="#fedosovDistChetaSheet">(Fedosov, n.d.)</a> Logical clocks are not about actual time, it’s about an order of events (about partial order?), where events are connected by a happens-before relation.
    <ul>
      <li>Lamport timestamps</li>
      <li>Vector Clocks</li>
    </ul>
  </li>
  <li><strong>Concurrent Operations and Causality</strong>: An operation A happens before another operation B if B knows about A, or depends on A, or builds upon A in some way. Whether one operation happens before another operation is the key to defining what concurrency means. In fact, we can simply say that <strong>two operations are concurrent if neither happens before the other, i.e. neither knows about the other</strong>. Thus, whenever you have two operations A and B, there are three possibilities: either A happened before B, or B happened before A, or A and B are concurrent.
    <ul>
      <li>Although causality is an important theoretical concept, actually keeping track of all causal dependencies can become impractical. In many applications, clients read lots of data before writing something, and then it is not clear whether the write is causally dependent on all or only some of those prior reads. Explicitly tracking all the data that has been read would mean a large overhead. However, there is a better way: we can use sequence numbers or timestamps to order events.</li>
    </ul>
  </li>
  <li><strong>Causality and achieving consensus</strong>
    <ul>
      <li>see also <a href="##transaction-isolation">Transaction, Isolation</a> and <a href="###consensus-algorithms-me">Consensus Algorithms and Distributed Lock</a></li>
      <li>compare-and-set register</li>
      <li>atomic transaction commit in DB</li>
      <li>Locks and leases</li>
      <li>membership/coordination service - system must decide which nodes are alive and up-to-date</li>
      <li>uniqueness constraint to decide which ones will violate constraints</li>
      <li>total-order broadcast: 1) no-messages are lost 2)same order for every node.</li>
    </ul>
  </li>
</ul>

<h2 id="synchronicity-and-consistency">Synchronicity and Consistency</h2>

<ul>
  <li><strong>Synchronous</strong>- data is written to all nodes, and only then acknowledged to client. Impractical as one node outage could halt the whole system.</li>
  <li><strong>Semi-Synchronous</strong> - usually means that one of the followers is synchronous, and the others are asynchronous. If the synchronous follower becomes unavailable or goes slow, one of the asynchronous followers is made synchronous.</li>
  <li><strong>Asynchronous + eventual consistency</strong> - client receives acknowledgement after master handles the data. Copy to replicas is done asynchronous.
    <ul>
      <li>if you stop writing and wait a while - followers will eventually catch up</li>
    </ul>
  </li>
  <li><strong>Strong consistency</strong> - all nodes see values in the same order.</li>
  <li><strong>Causal</strong> - read order matches write order of causal related events.</li>
  <li><strong>Weak</strong> - all nodes may not see the same order
    <ul>
      <li><strong>Monotonic read consistency</strong> - if client makes several reads in order, time will not go backwards. Achievable by ensuring reads are done from the same replica. But different users can read from different replicas.</li>
      <li><strong>eventual consistency</strong></li>
    </ul>
  </li>
</ul>

<p><img src="pics\synchronicity.jpg" alt="synchronicity" title="Synchronicity" /></p>

<h3 id="consensus-algorithms-me">Consensus Algorithms <strong>[me]</strong></h3>

<ul>
  <li><strong>2-phase commit</strong>
    <ul>
      <li>coordinator sends a commit query to all participants</li>
      <li>participants execute transaction up to commit point, and write entries to their redo and undo logs</li>
      <li>participants reply with agreement/abort messages</li>
      <li>if all YES, coordinator sends a commit message
        <ul>
          <li>each participant completes the operation and releases all locks/resources</li>
        </ul>
      </li>
      <li>if NO, coordinator sends a rollback message
        <ul>
          <li>each participant undoes the transaction and releases all locks/resources</li>
        </ul>
      </li>
      <li>each participant sends an acknowledgement to the coordinator</li>
      <li>coordinator completes transaction when all acknowledgements are received.</li>
    </ul>
  </li>
  <li><strong>PAXOS</strong></li>
  <li><strong>RAFT</strong> used by Hazelcast</li>
</ul>

<h2 id="replication">Replication</h2>

<ul>
  <li><a class="citation" href="#burns2019kubernetes">(Burns et al., 2019)</a> Replica: each replica has all data (useful for stateless services)</li>
  <li><a class="citation" href="#burns2019kubernetes">(Burns et al., 2019)</a> Sharding: each shard is only capable of serving a subset of all requests. (useful for stateful services)</li>
  <li><a class="citation" href="#burns2019kubernetes">(Burns et al., 2019)</a> Scatter/Gather: Each replica does a small amount of processing and then returns a fraction of the result to the root. The root server then combines the various partial results together to form a single complete response to the request and then sends this request back out to the client.
    <ul>
      <li>Scatter/gather can be seen as sharding the computation necessary to service the request, rather than sharding the data (although data sharding may be part of it as well).</li>
    </ul>
  </li>
  <li><strong>Single-leader replication</strong>: Clients send all writes to a single node (the leader), which sends a stream of data change events to the other replicas (followers). Reads can be performed on any replica, but reads from followers might be stale.</li>
  <li><strong>Multi-leader replication</strong>: Clients send each write to one of several leader nodes, any of which can accept writes. The leaders send streams of data change events to each other, and to any follower nodes.</li>
  <li><strong>Leaderless replication</strong>: Clients send each write to several nodes, and read from several nodes in parallel in order to detect and correct nodes with stale data.</li>
</ul>

<h2 id="partitioning">Partitioning</h2>

<ul>
  <li><strong>Key range partitioning</strong> This has the advantage that efficient range queries are possible, but there is a risk of hot spots if the application often accesses keys that are close together in the sorted order. In this approach, partitions are typically re-balanced dynamically, by splitting the range into two sub-ranges when a partition gets too big.</li>
  <li><strong>Hash partitioning</strong>, where a hash function is applied to each key, and a partition owns a range of hashes. This destroys the ordering of keys, making range queries inefficient, but may distribute load more evenly. When partitioning by hash, it is common to create a fixed number of partitions in advance, to assign several partitions to each node, and to move entire partitions from one node to another when nodes are added or removed.</li>
  <li><strong>2nd index</strong>
    <ul>
      <li>Document-partitioned index: the secondary indexes are stored in the same partition as the primary key and value. This means that only a single partition needs to be updated on write, but a read of the secondary index requires a scatter/gather across all partitions.</li>
      <li>Term-partitioned index (global index): the secondary indexes are partitioned separately, using the indexed values. An entry in the secondary index may include records from all partitions of the primary key. When a document is written, several partitions of the secondary index need to be updated; however, a read can be served from a single partition.</li>
    </ul>
  </li>
  <li><strong>Logical Partitioning</strong> partition data on nodes, depending on specific logic</li>
  <li><strong>Partial</strong> (or Vertical) each node keeps partial information about each object (e.g. some attributes)</li>
</ul>

<h2 id="transaction-isolation">Transaction, Isolation</h2>

<ul>
  <li><strong>Read committed</strong> ensures that
    <ul>
      <li>only committed data is overwritten (no dirty writes)</li>
      <li>only committed data is read (no dirty reads)</li>
    </ul>
  </li>
  <li><strong>snapshot isolation</strong>, also known as <strong>multiversion concurrency control (MVCC)</strong> - each transaction sees the data from the time when that transaction started.
    <ul>
      <li>Optimistic - instead of blocking if something potentially dangerous happens, transactions continue anyway, in the hope that everything will turn out alright. When a transaction wants to commit, the database checks whether anything bad happened (i.e. whether isolation was violated); if so, the transaction is aborted and has to be retried. Only transactions which executed serializably are allowed to commit.</li>
      <li>On top of snapshot isolation, SSI adds an algorithm for detecting serialization conflicts among writes, and determining which transactions to abort.</li>
      <li>(see “Serializable snapshot isolation (SSI)” on page 252)</li>
    </ul>
  </li>
  <li><strong>serializable isolation</strong>, the strongest one. It guarantees that even though transactions may execute in parallel, the end result is the same as if they had executed one at a time, serially, without any concurrency.
    <ul>
      <li>(see “Actual serial execution” on page 243)</li>
    </ul>
  </li>
  <li><strong>2-phase lock</strong> (me - similar to read/write lock)
    <ul>
      <li>Several transactions can have a lock in shared mode simultaneously, unless no transaction has exclusive lock.</li>
      <li>to write - get exclusive lock, but when switching to read, can have shared lock.</li>
      <li>transaction must hold the lock until it is finished (commit or abort), where the 2-phase comes from.</li>
      <li>(see “Two-phase locking (2PL)” on page 248)</li>
    </ul>
  </li>
</ul>

<h2 id="references">References</h2>




<ul class="bibliography"><li><span id="burns2019kubernetes">Burns, B., Hightower, K., &amp; Beda, J. (2019). <i>Kubernetes: up and running</i>.</span></li>
<li><span id="fedosovDistChetaSheet">Fedosov, D. <i>Distributed systems cheat sheet</i>. Retrieved January 31, 2021, from http://dimafeng.com/2016/12/04/distributed-systems/</span></li>
<li><span id="kleppmann2017designing">Kleppmann, M. (2017). <i>Designing data-intensive applications : the big ideas behind reliable, scalable, and maintainable systems</i>. O’Reilly Media.</span></li>
<li><span id="newman2015building">Newman, S. (2015). <i>Building microservices : designing fine-grained systems</i>. O’Reilly Media.</span></li>
<li><span id="rivers2017best">Rivers, A. (2017). <i>Best Practices for Tracing and Debugging Microservices</i>. https://dzone.com/articles/best-practices-for-tracing-and-debugging-microserv</span></li></ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
  
    <div class="wrapper">
  
      <div class="footer-col-wrapper">
        <div class="footer-col">
        <!--
          <p class="feed-subscribe">
            <a href="/feed.xml">
              <svg class="svg-icon orange">
                <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
              </svg><span>Subscribe</span>
            </a>
          </p>
        -->
          <ul class="contact-list">
            <li class="p-name">emodemo</li>
            
          </ul>
        </div>
        <div class="footer-col">
          <p>emodemo&#39;s notes on development, fiction, science and other stuff.</p>
        </div>
      </div>
  
      <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/emodemo" title="emodemo"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://www.linkedin.com/in/emiliyan-todorov" title="emiliyan-todorov"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a rel="me" href="https://twitter.com/emodemo15" title="emodemo15"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>
  
    </div>
  
  </footer></body>

</html>
